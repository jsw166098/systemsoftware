# ARM
* 32 bit RISC 프로세서
* Arcon Computer 사에서 처음 사용
* 저전력 사용(사물인터넷, 임베디드, 스마트폰)

## CISC vs RISC

둘다 쉽게 말해 컴퓨터 연산 집합이며 명령어 set이다. 

### CISC 
* 명령어 길이가 가변적
* 생산성이 높다. 많은 수의 다양한 종류의 길이 형태로 기능들을 구현할 수 있다.
* 복잡하다는 단점이 있다.
* cpu 설계가 어렵다는 단점이 있다.

### RISC
* 명령어 길이가 고정적
* 모든 명령어의 길이가 동일하다.
* 명령어의 처리시간이 모두 동일하다.
* 시간을 고려할 필요가 없기 때문에 처리시간이 빠르다.
* 간단하며 복잡하지 않은 구조와 설계를 가지고 있다. 
* 불필요한 연산들이 제거된 형태로 볼 수 있다. 더 적은 연산들을 가지고 있다.
* transister의 개수가 적어서 전력 소모량이 낮다.
* 일처리와 효율이 좋다. 
* 고정된 명령어로 프로그램을 만들어야 하기 때문에 프로그램이 커지는 단점이 있다. 

---

## 범용 레지스터(R0~R12)
다목적 레지스터로 사용되고 인자값이나 임시 계산 저장용으로 사용된다. 레지스터마다 하는일이 정해져있는 건 맞지만 하는 일이 유일하지 않고 다양하다.

* R0 : 함수 리턴 값 저장 ; 함수가 호출된 후 return 하는 값을 저장하는 레지스터
* R0~3 : 함수 호출 인자 전달 ; 함수의 매개변수 값을 저장하는 레지스터로 함수가 호출될 때 매개뱐수 값을 전달한다.
* R11 : 스택 프레임 포인터 ; 스택 메모리 주소를 저장하는 레지스터이며 함수가 호출되기 전에 스택 메모리 주소를 저장한다. 스택 프레임이란 함수 호출 과정에서 할당되는 메모리 블럭으로 호출 되기 전 스택의 top의 위치를 가리키는 포인터이다. 함수 호출이 끝나고 반환될 시점에 스택 프레임의 메모리 영역을 스택에서 제외하기 위해 스택 포인터 레지스터가 가리키는 지점을 옮겨야 하는데 이때 스택 프레임 포인터 값으로 옮기면 무사히 스택에 점유하고 있던 직전에 호출했던 함수의 스택 프레임 영역을 제외할 수 있게 된다. 

## 특수 레지스터 
* R13: 스택 포인터 레지스터(SP) ; 스택의 메모리 주소를 저장한다. 스택의 top 위치를 저장하고 있으며 따라서 현재 스택이 어디까지 쌓여 있는지 저장하게 된다. 
* R14 : 링크 레지스터(LR) ; 명령어 실행 중 함수 호출을 위해 해당 함수의 주소로 이동할 때 그 다음 실행해야할 명령어 주소를 저장한는 레지스터이다. 
* R15 : program counter(PC) ; 현재 수행 위치를 가리키는 레지스터이다. 실행해야할 명령어들은 메모리에 위치하고 있으며 순차적으로 해당 명령어의 메모리 주소를 가리키면서 가리킨 명령어들을 실행하게 된다. 이때 실행되는 명령어의 주소값이 저장되는 레지스터가 PC이다. 다시 말해 명령어 집합이 저장된 메모리에서 특정 명령어를 실행하고자 한다면 해당 명령어의 주소를 PC에 저장하면 된다. 이때 하나의 명령어 수행을 마치고 다음 명령어로 이동하기위한 거리는 정해진 명령어 단위로 계산되며 보통은 1워드이다.
* CPSR(current program status register) : 현재 프로그램 상태 레지스터 ; 연산결과, iqr, 동작모드 등을 저장하는 레지스터이며 **condition flag**나 현재 **mode**를 나타내는 값들이 저장되어 있다. 
* SPSR(Saved Program Status Register) : CPSR 값을 저장해두는 역할로 CPSR을 backup 할 때 사용한다. ; 명령어를 수행할 때마다 CPSR에 저장되는 상태 레지스터 값은 변하기 때문에 이전의 값을 저장하는 레지스터이다.

## Condition Flag
* N(Negative) : 연산 결과가 음수인 경우 참
* Z(Zero) : 연산 결과가 0인 경우 참
* C(Carry) : 연산 결과 혹운 shift operation의 결과에서 자리 올림 발생 시 참
* V(Overflow) : 연산 결과에서 overflow가 발생하였을 때 참 ; 산술 연산 시 주어진 비트를 넘게 되면 1값을 가진다. 

## Mode 
mode를 표시하는 bit
* T(state bit) : ARM mode인지 Thumb mode인지 나타냄 -> Thumb는 ARM을 전부 반으로 줄인 버전 (기존의 명령어를 압축한 버전)
* M0~M4(Mode bits) : 현재 어떤 모드인지 나타냄 


